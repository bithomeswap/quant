import math
from jqdata import *
import pandas as pd
import json
def initialize(context):
    # 设置交易日计数器
    context.day_counter = 0
    # 初始化函数，在此处添加打印语句
    print('任务已经开始')
    # 设定沪深300、中证1000、上证指数作为基准
    # set_benchmark('000300.XSHG')
    # set_benchmark('000852.XSHG')
    set_benchmark('000001.XSHG')
    # # 设置成交量比例
    # set_option('order_volume_ratio', 0.1)
    # # 开启盘口撮合模式
    # set_option('match_with_order_book', True)
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 开启避免未来函数模式
    set_option("avoid_future_data", True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    # 定时运行买入卖出函数
    run_daily(buy, time='9:35')
    run_daily(sell, time='13:35')
    g.allorders=pd.DataFrame() # 储存历史订单
    g.name = ("000", "001", "002", "600", "601", "603", "605") # 主板
    # g.name = ("300", "688") # 创业板
    # g.name = ("ETF")

# 固定时间交易
def buy(context):
    today = context.current_dt.date()
    if  "ETF" in g.name:
        df = get_all_securities(types=['etf'],date=today)
        df = df.index
        stocks = df.tolist()
        df = get_price(stocks, start_date=today,end_date=today, fields=['open', 'high', 'low', 'close', 'money'],panel=False )
        df = df.rename(columns={'code': '代码','open': '开盘', 'high': '最高', 'low': '最低', 'close': '收盘', 'money': '成交额'})
        df['振幅'] = (df['最高'] - df['最低']) / df['开盘']
        df['资金波动'] = df['振幅'] / df['成交额']
        df = df.sort_values(by=['资金波动'], ascending=False)
        df['资金波动_rank'] = df['资金波动'].rank(ascending=False)/len(df)
        df=df[df['资金波动_rank']<0.1]
    if  "000" or "300" in g.name:
        name=g.name
        df = get_all_securities(types=['stock'],date=today).index
        df = df[df.str.startswith(name)].tolist()
        curr_data = get_current_data()
        stocks=[stock for stock in df if not (
            # (curr_data[stock].day_open == curr_data[stock].high_limit) or  # 涨停开盘
            # (curr_data[stock].day_open == curr_data[stock].low_limit) or  # 跌停开盘
            curr_data[stock].paused or  # 停牌
            curr_data[stock].is_st 
            # or  # ST
            # ('ST' in curr_data[stock].name) or
            # ('*' in curr_data[stock].name) or
            # ('退' in curr_data[stock].name)
            )]
        df = get_price(stocks,count=1,end_date=today-datetime.timedelta(days=1),fields=['open', 'high', 'low', 
            'close','pre_close','money'],panel=False )
        df = df.rename(columns={'code': '代码','open': '开盘', 'high': '最高', 'low': '最低', 
            'close': '收盘','pre_close':'前收','money': '成交额'})
        # 增加基本面数据
        df_fundamentals = get_fundamentals(query(
            valuation.code, valuation.market_cap, valuation.pe_ratio,income.total_operating_revenue,
            balance.total_assets, balance.total_liability), date=today-datetime.timedelta(days=1),)
        df_fundamentals = df_fundamentals.rename(columns={"code": "代码", "market_cap":"总市值","pe_ratio":"市盈率",
                                            "total_operating_revenue":"营收","total_assets": "总资产", "total_liability": "总负债"})
        df= pd.merge(df, df_fundamentals, on='代码') # 增加设置基本面因子
        df_valuation= get_valuation(stocks,count=1,end_date=today-datetime.timedelta(days=1),fields=['capitalization', 'market_cap','turnover_ratio'])
        df_valuation = df_valuation.rename(columns={'code': '代码','turnover_ratio': '换手率'})
        df= pd.merge(df, df_valuation, on='代码') # 增加设置换手率因子
        # 资金波动因子(反映控盘程度)
        df['振幅'] = (df['最高'] - df['最低']) / df['开盘']
        df['资金波动'] = df['振幅'] / df['成交额']
        df['涨跌幅'] = df['收盘'] / df['前收']
        df['资金贡献'] = (df['涨跌幅'] / df['成交额'])-1
        # # 基本面市销率因子(反映成长性)加不加区别不大
        df['净资产']= df['总资产'] - df['总负债']
        df['市销率']=(df['总市值']*10000000)/df['营收']
        df['市净率']=(df['总市值']*10000000)/df['净资产']
        df['市盈率']=1/df['市盈率']
        # # 截面因子（标的排名因子）
        # df['总市值_rank'] = df['总市值'].rank(ascending=False)/len(df)
        # df['成交额_rank'] = df['成交额'].rank(ascending=False)/len(df)
        # df['振幅_rank'] = df['振幅'].rank(ascending=False)/len(df)
        # df['涨跌幅_rank'] = df['涨跌幅'].rank(ascending=False)/len(df)
        # df['换手率_rank'] = df['换手率'].rank(ascending=False)/len(df)
        df['资金波动_rank'] = df['资金波动'].rank(ascending=False)/len(df)
        df['资金贡献_rank'] = df['资金贡献'].rank(ascending=False)/len(df)
        # df['市销率_rank'] = df['市销率'].rank(ascending=False)/len(df)
        # df['市盈率_rank'] = df['市盈率'].rank(ascending=False)/len(df)
        # df['市净率_rank'] = df['市净率'].rank(ascending=False)/len(df)
        # df=df[df['总市值_rank']>0.8]
        # df=df[df['成交额_rank']>0.8]
        # df=df[df['振幅_rank']>0.1]
        # df=df[df['涨跌幅_rank']>0.1]
        # df=df[df['换手率_rank']>0.5]
        df=df[df['资金波动_rank']<0.1]
        # df=df[df['资金贡献_rank']<0.1]
        # df=df[df['市销率_rank']>0.5]
        # df=df[df['市盈率_rank']>0.5]
        # df=df[df['市净率_rank']>0.5]
        
        df=df[(df['市销率']>(1/3))]
        df=df[(df['市盈率']>(1/50))]
        dfall=df
        # 二次过滤
        stocks=df['代码'].tolist()
        df = get_price(stocks,count=1,end_date=today-datetime.timedelta(days=1),frequency='daily',
                    skip_paused=True,fields=['open','pre_close'],panel=False)
        df = df.rename(columns={'code':'代码','open': '开盘','pre_close':'前收'})
        df['开盘幅']=df['开盘']/df['前收']
        # df['abs涨跌幅']=abs(df['涨跌幅'])
        # df= df.nsmallest(10, "abs涨跌幅")
        # df= df.nsmallest(10, f"总市值")
        # df = df.nsmallest(10, f"开盘幅")
        df= df.nlargest(10, f"开盘幅")
        # df = df.sort_values(by=['abs涨跌幅'], ascending=False)
        # df = df.sort_values(by=['振幅'], ascending=False)
        df= df.sort_values(by=['开盘幅'], ascending=False)
        df=df[df['开盘']>4]
        print(len(df),len(dfall))
        # 观察目标股票占整体候选股票的比例，如果比较高说明比较安全可以交易，比较低就比较危险，需要谨慎。
        # 2014.6:0.25-0.5
        # 2015.6:0.1-0.25
        # 2016.6:0.2-0.3
        # 2017.6:0.1-0.25
        # 2018.6:0.25-0.35
        buystocks=df
        # if len(df)>len(dfall)*0.1:
        #     buystocks=df # 将拟购买标的赋值给全局变量
        # else:
        #     buystocks=pd.DataFrame() #市场危险，不宜建仓
        if not buystocks.empty: # 持仓权重确认（不超过百分之五）
            for newstock in buystocks['代码']:
                position=context.portfolio.positions.keys()
                for stock in position:
                    if context.portfolio.positions[stock].security==newstock:
                        # # 已有持仓不买入
                        # buystocks=buystocks[buystocks['代码']!=newstock] # 删除元素
                        # print(context.portfolio.positions[stock].security,'已有持仓，不宜买入')
                        # 持仓过重不买入
                        if(context.portfolio.positions[stock].closeable_amount+context.portfolio.positions[stock].locked_amount)>(context.portfolio.total_value/10):
                            buystocks=buystocks[buystocks['代码']!=newstock] # 删除元素
                            print(context.portfolio.positions[stock].security,'仓位过重，不宜买入')
        if not buystocks.empty:
            print(buystocks['代码'],type(buystocks['代码']))            
        buystock=buystocks['代码'].tolist()
        if(len(buystock))>0:
            for stock in buystock:
                m=50 # 固定滚仓模式（每笔下单不超过百分之五，适合小资金）
                if(context.portfolio.available_cash)>(context.portfolio.total_value/m):
                    target_value =context.portfolio.total_value/m
                    value_per_stock = target_value
                    order=order_value(stock, value_per_stock)
                    log.info("Buying", order)
                # m=30 # 固定滚仓模式（每天平均下单最多百分之三，适合大资金）
                # if(context.portfolio.available_cash)<(context.portfolio.total_value/m):
                #     target_value =context.portfolio.available_cash
                # else:
                #     target_value =context.portfolio.total_value/m
                # value_per_stock = target_value/len(buy_list)
                # order=order_value(stock, value_per_stock)
                # # log.info("Buying", order)
        context.day_counter += 1
def sell(context):
    if  "000" or "300" in g.name:
        today = context.current_dt.date()
        orders = get_orders()
        i=0
        df = pd.DataFrame(columns=['order_id','status','security','price','amount',
                'avg_cost','Time','is_buy','filled','side','action'])
        for _orders in orders.values():
            if (str(_orders.status)!='canceled') and(str(_orders.action)!='close'): # 去掉未成交订单
                df.loc[i,'order_id'] = _orders.order_id
                df.loc[i,'status'] = str(_orders.status) # 订单状态
                df.loc[i, 'security'] = _orders.security # 代码（str）
                df.loc[i,'price'] = _orders.price # 委托价格（float）
                df.loc[i,'amount'] = _orders.amount # 委托数量(int)
                df.loc[i,'avg_cost'] = _orders.avg_cost # 交易均价（float）
                df.loc[i, 'Time'] = _orders.add_time # 委托时间(datetime.datetime)
                df.loc[i, 'filled'] = _orders.filled # 已成交量(int)，可能是手数
                df.loc[i, 'side'] = _orders.side # 多头还是空头(str)
                df.loc[i, 'action'] = _orders.action # 开仓还是平仓（进场还是出场）(str)
                i=i+1
        g.allorders=pd.concat([g.allorders,df],ignore_index=True)
        for order_id in g.allorders['order_id']:
            df=g.allorders[g.allorders['order_id'] == order_id]
            stock=df['security'].values[0]
            starttime=df['Time'].values[0].date()
            hold_days = (today - starttime).days
            if (hold_days >= 1) and not(get_current_data()[stock].paused): # 持仓大于一天且当日不停牌
                n=hold_days # 设置趋势观察周期
                df_cta = get_price(stock,count=n,end_date=today, frequency='daily',skip_paused=True,fields=['open'],panel=False)
                if df_cta['open'][n-1]<df['avg_cost'].values[0]*0.95:# 浮亏百五卖出（止损）
                    take='止损'
                    sellorder=order(stock,-df['filled'].values[0])
                    log.info("selling",take,sellorder)
                    if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
                        g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()
                    break
                # if (hold_days >= 3):
                #     if not(any(df_cta['open'][2] > df_cta['open'].iloc[:2].values)): # 破三日新低卖出
                #         take='破位'
                #         sellorder=order(stock,-df['filled'].values[0])
                #         log.info("selling",take,sellorder)
                #         if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
                #             g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()
                #         break
                if (hold_days >= 10) and not(get_current_data()[stock].paused):
                    divisors = np.arange(1, len(df_cta)+1) 
                    df_rate = ((df_cta/(df['avg_cost'].values[0]))-1).div(divisors, axis=0)
                    df_rate=df_rate['open'].max() # 定义历史斜率最大值为盈利斜率
                    # 止损线上移，每日上移一个盈利斜率
                    if(df_cta['open'][n-1] < (df['avg_cost'].values[0])*(0.95+df_rate*hold_days)):
                        take='长期止损'
                        sellorder=order(stock,-df['filled'].values[0])
                        log.info("selling",take,sellorder)
                        if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
                            g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()
                        break
                if not(get_current_data()[stock].paused):
                    df_lastrate = df_cta['open']/df_cta['open'].shift(1)
                    lastindex=pd.Index(df_lastrate > 1.09).where(df_lastrate>1.09).tolist()
                    last=list(filter(lambda x: not math.isnan(x), lastindex))
                    if (len(last)>0): # 判断持仓期间是否有涨停
                        index=len(lastindex)-lastindex[::-1].index(True)
                        if index<5: # 上次涨停位置<5 且 最高点回撤>0.2
                            if df_cta['open'][n-1]<df_cta['open'].max()*0.8:
                                take='赶顶'
                                sellorder=order(stock,-df['filled'].values[0])
                                log.info("selling",take,sellorder)
                                if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
                                    g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()
                                break
                    if (hold_days >= 10) and ((len(last)==0) or ((len(last)>0) and (index>10))):
                        if df_rate<((df_cta['open'][n-1]/df_cta['open'][n-4])-1)and (df_cta['open'][n-1]<0):
                            take='回调'
                            sellorder=order(stock,-df['filled'].values[0])
                            log.info("selling",take,sellorder)
                            if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
                                g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()
                            break
            # if hold_days >= 30:（固定周期滚仓模式，适合大资金，要求基本面较好的前提下资金波动前百分之十中选择一部分）
            #     sellorder=order(stock,-df['filled'].values[0])
            #     # log.info("selling", sellorder)
            #     if sellorder!=None: # 避免股票停牌等异常导致order的返回值为空值进而导致当日无法交易
            #         g.allorders = g.allorders[g.allorders['order_id']!= order_id].copy()