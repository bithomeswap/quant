import math
from jqdata import *
import pandas as pd
import json

def initialize(context):
    # 设置交易日计数器
    context.day_counter = 0
    # 初始化函数，在此处添加打印语句
    print('任务已经开始')
    # 设定沪深300、中证1000、上证指数作为基准
    # set_benchmark('000300.XSHG')
    # set_benchmark('000852.XSHG')
    set_benchmark('000001.XSHG')
    # 设置成交量比例
    set_option('order_volume_ratio', 0.1)
    # # 开启盘口撮合模式
    # set_option('match_with_order_book', True)
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 开启避免未来函数模式
    set_option("avoid_future_data", True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')
    # 定时运行买入卖出函数
    run_daily(buy, time='9:35')
    run_daily(sell, time='14:00')
    g.stocks=[] # 储存拟买入的标的
    g.allorders=pd.DataFrame() # 储存历史订单
    # g.road='CTA'
    g.road='no'
    g.name = ("000", "001", "002", "600", "601", "603", "605") # 主板
    # g.name = ("300", "688") # 创业板
    # g.name = ("ETF")
    g.sell=[]
    
def after_trading_end(context):
    today = context.current_dt.date()
    if "ETF" in g.name:
        df = get_all_securities(types=['etf'],date=today)
        df = df.index
        stocks = df.tolist()
        df = get_price(stocks, start_date=today,end_date=today, fields=['open', 'high', 'low', 'close', 'money'],panel=False )
        df = df.rename(columns={'code': '代码','open': '开盘', 'high': '最高', 'low': '最低', 'close': '收盘', 'money': '成交额'})
        df['振幅'] = (df['最高'] - df['最低']) / df['开盘']
        df['资金波动'] = df['振幅'] / df['成交额']
        df = df.sort_values(by=['资金波动'], ascending=False)
        df['资金波动_rank'] = df['资金波动'].rank(ascending=False)/len(df)
        df=df[df['资金波动_rank']<0.01]
        print(df)
        g.stocks=df['代码']
    if  "000" or "300" in g.name:
        name=g.name
        df = get_all_securities(types=['stock'],date=today).index
        df = df[df.str.startswith(name)].tolist()
        curr_data = get_current_data()
        stocks=[stock for stock in df if not (
            # (curr_data[stock].day_open == curr_data[stock].high_limit) or  # 涨停开盘
            # (curr_data[stock].day_open == curr_data[stock].low_limit) or  # 跌停开盘
            curr_data[stock].paused or  # 停牌
            curr_data[stock].is_st or  # ST
            ('ST' in curr_data[stock].name) or
            ('*' in curr_data[stock].name) or
            ('退' in curr_data[stock].name)
            )]
        df = get_price(stocks, start_date=today,end_date=today, fields=['open', 'high', 'low', 'close', 'money'],panel=False )
        df = df.rename(columns={'code': '代码','open': '开盘', 'high': '最高', 'low': '最低', 'close': '收盘', 'money': '成交额'})
        # 资金波动因子(反映控盘程度)
        df['振幅'] = (df['最高'] - df['最低']) / df['开盘']
        df['资金波动'] = df['振幅'] / df['成交额']
        df = df.sort_values(by=['资金波动'], ascending=False)
        df['资金波动_rank'] = df['资金波动'].rank(ascending=False)/len(df)
        df=df[df['资金波动_rank']<0.01]
        # 增加设置基本面因子
        df_fundamentals = get_fundamentals(query(
            valuation.code, valuation.market_cap, valuation.pe_ratio,income.total_operating_revenue,
            balance.total_assets, balance.total_liability), date=today)
        df_fundamentals = df_fundamentals.rename(columns={"code": "代码", "market_cap":"总市值","pe_ratio":"市盈率",
                                            "total_operating_revenue":"营收","total_assets": "总资产", "total_liability": "总负债"})
        # df_valuation= get_valuation(stocks,end_date=today,count=30,fields=['capitalization', 'market_cap','turnover_ratio'])
        # df_valuation = df_valuation.rename(columns={'code': '代码','turnover_ratio': '换手率'})
        # 增加设置cta因子
        # df_cta = get_price(stocks,count=5,end_date=today, frequency='daily',skip_paused=True,fields=['open'],panel=False)
        # df_cta = df_cta[(df['open'][4]>df['open'][0])&(df['open'][4]/df['open'][3]<1.02)]
        df= pd.merge(df, df_fundamentals, on='代码') # 增加设置基本面因子
        # df= pd.merge(df, df_valuation, on='代码') # 增加设置换手率因子
        # df= pd.merge(df, df_cta, on='代码') # 增加设置cta因子
        
        # 基本面市销率因子(反映成长性)加不加区别不大
        # df=df[df['换手率']<1] # 换手率低说明标的相对安全
        df['净资产']= df['总资产'] - df['总负债']
        df['市销率']=(df['总市值']*10000000)/df['营收']
        df['市净率']=(df['总市值']*10000000)/df['净资产']
        df['市盈率']=1/df['市盈率']
        df = df[(df['市销率']>(1/1))] # 市销率为1有1600+股票，为1.5有2000+股票
        # df = df[(df['市净率']>(1/3))] # 市销率为1有1600+股票，为1.5有2000+股票
        df = df[(df['市盈率']>(1/50))] # 市销率为1有1600+股票，为1.5有2000+股票
        # df= df.nsmallest(1, f"总市值")
        # df= df.nsmallest(1, f"收盘")
        # df= df.nlargest(1, f"市盈率")

        g.stocks=df['代码'] # 将拟购买标的赋值给全局变量
        print(g.stocks,type(g.stocks))
        for newstock in df['代码']:
            # 加上计算形态好的占据总股票观察池的比例(低于多少就不开单)
            
            position=context.portfolio.positions.keys()
            i=0
            df = pd.DataFrame(columns=['security','price','acc_avg_cost','avg_cost','Time','transact_time','total_amount',\
                'closeable_amount','today_amount','locked_amount','value','side'])
            for stock in position:
                if context.portfolio.positions[stock].security==newstock:
                    if (context.portfolio.positions[stock].closeable_amount+context.portfolio.positions[stock].locked_amount)>0.05*0.05*context.portfolio.total_value:
                        # g.stocks.append(context.portfolio.positions[stock].security) # 添加元素
                        g.stocks=g.stocks[g.stocks!=context.portfolio.positions[stock].security] # 删除元素
                        print(g.stocks,type(g.stocks))
                        # print('仓位过重，不宜买入')
                # df.loc[i,'security']=context.portfolio.positions[stock].security # 代码（str）
                # df.loc[i,'price'] = context.portfolio.positions[stock].price # 最新行情价格（float）
                # df.loc[i,'acc_avg_cost'] = context.portfolio.positions[stock].acc_avg_cost # 累计持仓成本，减仓、加仓均更新
                # df.loc[i,'avg_cost'] = context.portfolio.positions[stock].avg_cost # 持仓成本（浮动盈亏），仅仅加仓更新
                # df.loc[i, 'Time'] = context.portfolio.positions[stock].init_time # init_time: 建仓时间
                # df.loc[i,'transact_time'] = context.portfolio.positions[stock].transact_time # 最后交易时间
                # df.loc[i,'total_amount'] = context.portfolio.positions[stock].total_amount # 可卖出的仓位
                # df.loc[i,'closeable_amount'] = context.portfolio.positions[stock].closeable_amount # 总仓位(不包括挂单冻结仓位)
                # df.loc[i,'today_amount'] = context.portfolio.positions[stock].today_amount # 今天开的仓位
                # df.loc[i,'locked_amount'] = context.portfolio.positions[stock].locked_amount # 挂单冻结仓位
                # df.loc[i,'value'] = context.portfolio.positions[stock].value # 标的价值
                # df.loc[i,'side'] = context.portfolio.positions[stock].side # 多空
                # i=i+1
            # df.set_index('Time',drop=True,inplace=True)
            # print(df)
        print(g.stocks,type(g.stocks))

        
# 固定时间交易
def buy(context):
    today = context.current_dt.date()
    if "ETF" in g.name:
        buy_lists=g.stocks
        buy_list=[]
        if(len(buy_lists))>0:
            n=3
            for stock in buy_lists:
                df = get_price(stock,count=n,end_date=today, frequency='daily',skip_paused=True,
                    fields=['open'],panel=False)
                if df['open'][n-1]>df['open'][0]: # 突破n日突破前高
                    buy_list.append(stock)
            print(buy_list)
        if(len(buy_list))>0:
            for stock in buy_list:
                if context.day_counter < 30:
                    target_value = context.portfolio.starting_cash*(1/30)
                else: # 用全部余额买入
                    target_value = context.portfolio.available_cash
                value_per_stock = target_value/len(buy_list)
                order=order_value(stock, value_per_stock)
                log.info("Buying", order)
        context.day_counter += 1
    if  "000" or "300" in g.name:
        buy_lists=g.stocks
        buy_list=[]
        if(len(buy_lists))>0:
            n=3
            for stock in buy_lists: # 开盘价过滤低价股
                df = get_price(stock,count=n,end_date=today, frequency='daily',skip_paused=True,
                    fields=['open'],panel=False)
                if df['open'][n-1]>4: # 开盘价高于4元
                    buy_list.append(stock)
        if(len(buy_list))>0:
            for stock in buy_list:
                if context.day_counter < 30:
                    target_value = context.portfolio.starting_cash*(1/30)
                else: # 用全部余额买入
                    target_value = context.portfolio.available_cash
                value_per_stock = target_value/len(buy_list)
                buyorder=order_value(stock, value_per_stock)
                # log.info("Buying", buyorder)
        context.day_counter += 1
        
def sell(context):
    if  "000" or "300" in g.name:
        today = context.current_dt.date()
        orders = get_orders()
        i=0
        df = pd.DataFrame(columns=['order_id','status','security','price','amount',
                'avg_cost','Time','is_buy','filled','side','action'])
        for _orders in orders.values():
            if (str(_orders.status)!='canceled') and(str(_orders.action)!='close'): # 去掉未成交订单
                df.loc[i,'order_id'] = _orders.order_id
                df.loc[i,'status'] = str(_orders.status) # 订单状态
                df.loc[i, 'security'] = _orders.security # 代码（str）
                df.loc[i,'price'] = _orders.price # 委托价格（float）
                df.loc[i,'amount'] = _orders.amount # 委托数量(int)
                df.loc[i,'avg_cost'] = _orders.avg_cost # 交易均价（float）
                df.loc[i, 'Time'] = _orders.add_time # 委托时间(datetime.datetime)
                df.loc[i, 'filled'] = _orders.filled # 已成交量(int)
                df.loc[i, 'side'] = _orders.side # 多头还是空头(str)
                df.loc[i, 'action'] = _orders.action # 开仓还是平仓（进场还是出场）(str)
                i=i+1
        g.allorders=pd.concat([g.allorders,df],ignore_index=True)
        # print(g.allorders)
        for order_id in g.allorders['order_id']:
            df=g.allorders[g.allorders['order_id'] == order_id]
            stock=df['security'].values[0]
            starttime=df['Time'].values[0].date()
            hold_days = (today - starttime).days
            # if hold_days >= 2: # test
            if hold_days >= 30:
                sellorder=order(stock,df['filled'].values[0])
                # log.info("selling", sellorder)
                g.allorders = g.allorders[g.allorders['order_id'] != order_id]
                # print(hold_days,order_id)

# # 净资产代码
# df_balance = get_fundamentals(query(balance.code, balance.total_assets, balance.total_liability), date=today)
# df_balance = df_balance.rename(columns={"code": "代码", "total_assets": "总资产", "total_liability": "总负债"})
# df= pd.merge(df, df_price, on='代码')
# df= pd.merge(df, df_balance, on='代码')
# df["净资产"] = df['总资产'] - df['总负债']
# df['市销率']=df['营收']/(df['总市值']*100000000)
# df['市净率']=df['净资产']/(df['总市值']*100000000)
# df['资产负债率']=df['净资产']/df['总负债']