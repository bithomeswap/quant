工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

一、注意事项：
1.尽量使用向量化计算，避免频繁使用解释器导致效率降低
2.直接给我完整代码
3.可以使用参考代码，但是不一定准确，请你批判的使用

二、规则说明
1.可以但是不限制于使用梯度下降方法，寻找'df = df[(df['昨日资金波动_rank'] <= w*value/rank)].copy()
                df = df[(df['昨日资金贡献_rank'] <= v*value/rank)].copy()'中v和w分别的最优值
2.在数据初始化的时候，将每个月的数据单独提取出来输出csv的同时单独进行调优
3.给我能进行参数调优，并且观察到不同参数下收益情况的代码
4.希望将每一次的结果都保存为单独的csv方便我查询
零、参考链接
https://github.com/bithomeswap/quant/tree/master/
下数据获取文件夹中的choose.py、指标现货交易.py两个文件，代码逻辑借鉴这两个文件中的逻辑，访问的数据库也不变
一、参考代码
数据读取代码如下，其中for循环之后cash_balance的最终值越大，越符合我们的要求
# 获取当前.py文件的绝对路径
file_path = os.path.abspath(__file__)
# 获取当前.py文件所在目录的路径
dir_path = os.path.dirname(file_path)
# 获取当前.py文件所在目录的上两级目录的路径
dir_path = os.path.dirname(os.path.dirname(dir_path))
files = os.listdir(dir_path)
for file in files:
    for filename in names:
        if (filename in file) & ('指标' in file) & ('排名' not in file) & ('细节' not in file) & ('分钟' not in file):
            try:
                # 获取文件名和扩展名
                name, extension = os.path.splitext(file)
                path = os.path.join(dir_path, f'{name}.csv')
                print(name)
                df = pd.read_csv(path)
                df = df.sort_values(by='日期')  # 以日期列为索引,避免计算错误
                dates = df['日期'].copy().drop_duplicates().tolist()  # 获取所有不重复日期
                df = df.groupby(['代码'], group_keys=False).apply(
                    choose.technology)
                # 去掉噪音数据
                for n in range(1, 9):
                    df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 3*(1+n*0.2)]
                m = 0.001  # 设置手续费
                n = 6  # 设置持仓周期
                df, m, n = choose.choose('交易', name, df)
                df.to_csv(f'{name}交易细节.csv', index=False)  # 输出交易细节
                if updown == '盘中波动':
                    result_df = pd.DataFrame({})
                    cash_balance = 1  # 初始资金设置为1元
                    daily_cash_balance = {}  # 用于记录每日的资金余额
                    result = []
                    for date in dates:
                        day = dates.index(date)
                        days = dates[day-n:day]
                        # 取从n天前到当天的数据
                        daydf = df.loc[df['日期'].isin(days)]
                        daydf = daydf.fillna(1)
                        daydf = daydf.sort_values(by='日期')    # 以日期列为索引,避免计算错误
                        daydates = daydf['日期'].copy(
                        ).drop_duplicates().tolist()  # 获取所有不重复日期
                        daily_ret = 0
                        m = m/n  # 一天手续费均摊到n天就是
                        if daydates:
                            for i in range(0, len(daydates)-1):
                                ret = daydf[daydf['日期'] == daydates[i]
                                            ][f'{i+1}日后当日涨跌（未来函数）'].mean()*(1-m)-1
                                daily_ret += ret/n
                        cash_balance *= (1 + daily_ret)
                        daily_cash_balance[date] = cash_balance
                        result.append({'日期': date, f'盘中波动': cash_balance})
                    result_df = pd.concat([result_df, pd.DataFrame(result)])