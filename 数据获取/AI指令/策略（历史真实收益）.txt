
工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

一、注意事项：
1.尽量使用向量化计算，避免使用if语句和for循环，避免频繁使用解释器导致效率降低
2.直接给我完整代码
3.可以使用参考代码，但是不一定准确，请你批判的使用

二、规则说明
0.每一条交易记录都计算df[f'{n}日后当日收益']=([f'{n}日后总涨跌幅（未来函数）']+1)/([f'{n-1}日后总涨跌幅（未来函数）']+1)-1
1.初始资金为n+1，每次进行收益计算时，收益计算方式不变，但是每一份资金分别计算，计算的时间跨度为n；
2.每一份资金分别计算每回合的收益率和资产变动情况；
3.每天计算前n天内：
1天前所有标的的df[f'{1}日后当日收益']+
2天前所有标的的df[f'{2}日后当日收益']+
......
n天前所有标的的df[f'{n}日后当日收益']+
的和，即为当日理论上的盘中每日回撤（数据暂时不支持统计分钟级回撤），

参考资料：https: //github.com/bithomeswap/quant

一、参考代码
import math
import pandas as pd
import os
# 设置参数
names = ['ETF', '分钟ETF']
# names = ['分钟COIN', '分钟深证', '分钟上证']
# names = ['COIN', '深证', '上证']
# names = ['深证', '分钟深证', '上证', '分钟上证', 'COIN', '分钟COIN','ETF','分钟ETF']

for name in names:
    try:
        # 获取当前.py文件的绝对路径
        file_path = os.path.abspath(__file__)
        # 获取当前.py文件所在目录的路径
        dir_path = os.path.dirname(file_path)
        # 获取当前.py文件所在目录的上两级目录的路径
        dir_path = os.path.dirname(os.path.dirname(dir_path))
        file_path = os.path.join(dir_path, f'{name}指标.csv')
        df = pd.read_csv(file_path)

        code_count = len(df['代码'].drop_duplicates())
        print("标的数量", code_count)

        for n in range(1, 9):  # 去掉n日后总涨跌幅大于百分之三百的噪音数据
            df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 3*(1+n*0.2)]

        m = 0.001  # 设置手续费
        n = 18  # 设置持仓周期

        df = df.groupby('代码', group_keys=False)

        # 计算每个标的每个日期的未来当日收益(拿来确认回撤用)
        for i in range(1, n+1):
            col = f'{i}日后总涨跌幅（未来函数）'
            df[col+'_shift'] = df.groupby('代码')[col].shift(-i)
            # df[f'{i}日后当日收益'] = (df[col] + 1) / (df[col+'_shift'] + 1) - 1
            for j in range(0, n):
                for k in range(0, n):
                    df.loc[j+k+1, f'{k+1}份资金_{i}日后当日收益'] = (df.loc[j:k+j, col].mean() + 1) / (
                        df.loc[j:k+j, col+'_shift'].mean() + 1) - 1
        # # 计算累加收益率和回撤
        # df_grouped = df.groupby(['日期'], group_keys=False).apply(lambda x: x[[f'{i}日后当日收益' for i in range(1, n+1)]]).sum(axis=0).reset_index()
        # df_grouped['回撤'] = df_grouped.iloc[:, 1:].cumsum(axis=1).min(axis=1)
        # 每天的回撤应该是分别计算每份资金的当日持仓的回撤，例如说第1份资金

        # 将交易标的细节输出到一个csv文件
        trading_detail_filename = f'{name}交易细节.csv'
        df.to_csv(trading_detail_filename, index=False)

        cash_balance = 1  # 初始资金设置为1元
        daily_cash_balance = {}  # 用于每日的资金余额
        df_daily_return = pd.DataFrame(columns=['日期', '收益率'])
        cash_balance_list = []
        for date, group in df.groupby('日期'):
            if group.empty:  # 如果当日没有入选标的，则单日收益率为0
                daily_return = 0
            else:
                daily_return = (
                    (group[f'{n}日后总涨跌幅（未来函数）'] + 1).mean()*(1-m)-1)/n  # 计算平均收益率
            df_daily_return = pd.concat(
                [df_daily_return, pd.DataFrame({'日期': [date], '收益率': [daily_return]})])
            # 更新资金余额并记录每日资金余额
            cash_balance *= (1 + daily_return)
            daily_cash_balance[date] = cash_balance
            cash_balance_list.append(cash_balance)  # 添加每日资金余额到列表中
        df_cash_balance = pd.DataFrame(
            {'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})
        result_df = pd.merge(df_daily_return, df_cash_balance, on='日期')
        # 新建涨跌分布文件夹在上级菜单下，并保存结果
        parent_path = os.path.abspath('.')
        dir_name = '资产变动'
        dir_path = os.path.join(parent_path, dir_name)
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)
        result_df.to_csv(f'{dir_path}/{name}资产变动.csv')
        print('任务已经完成！')
    except Exception as e:
        print(f"发生bug: {e}")
