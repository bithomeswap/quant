
工作场景：
你是一名非常优秀的计算机工程师，注重代码的简洁性和可维护性，并且习惯采用向量化计算的手段提高代码的运行效率，同时你的代码当中很少有bug存在

一、注意事项：
1.尽量使用向量化计算，避免使用if语句和for循环，避免频繁使用解释器导致效率降低
2.直接给我完整代码
3.可以使用参考代码，但是不一定准确，请你批判的使用

二、规则说明
1.每日获取最近130个交易日的历史数据，进行指标计算，并筛选出符合要求的股票到钉钉进行二次分析
2.分别有两个数据库，一个是STOCK，一个是COIN，这里以STOCK为例
3.首先以日期分组，确定当日'BTCUSDT'的['SMA121开盘比值']列的值大于等于一，则标记为震荡策略，否则则标记为超跌
4.执行震荡策略时，使用如下代码筛选之后的结果就是目标标的
   # 牛市过滤
   for n in range(1, 10):  # 计算未来n日涨跌幅
        df = df[df[f'SMA{n*10}开盘比值'] >= 0.99].copy()
    # 选取当天'开盘'最低的
    n_top = math.floor(len(df)/20)
    df = df.nsmallest(n_top, '开盘')

5.执行超跌策略时，使用如下代码筛选之后的结果就是目标标的
   # 熊市过滤
   df = df[df['SMA120开盘比值'] <= 0.5].copy()
    for n in range(1, 10):  # 计算未来n日涨跌幅
        df = df[df[f'{n*10}日最低开盘价比值'] >= 1+n*0.01].copy()
6.将筛选出来的标的及细节发送到钉钉

参考资料：https: //github.com/bithomeswap/quant


一、参考代码
import math
import os
import talib
import pandas as pd
import requests
import json
import time
from pymongo import MongoClient
from binance.client import Client
# 设置参数
names = ['分钟COIN', '分钟深证', '分钟上证',]
# names = ['COIN', '深证', '上证',]


for name in names:
    try:
        # 获取当前.py文件的绝对路径
        file_path = os.path.abspath(__file__)
        # 获取当前.py文件所在目录的路径
        dir_path = os.path.dirname(file_path)
        # 获取当前.py文件所在目录的上两级目录的路径
        dir_path = os.path.dirname(os.path.dirname(dir_path))
        file_path = os.path.join(dir_path, f'{name}指标.csv')
        df = pd.read_csv(file_path)

        code_count = len(df['代码'].drop_duplicates())
        print("标的数量", code_count)

        for n in range(1, 9):  # 去掉n日后总涨跌幅大于百分之三百的噪音数据
            df = df[df[f'{n}日后总涨跌幅（未来函数）'] <= 3*(1+n*0.2)]


        # 将交易标的细节输出到一个csv文件
        trading_detail_filename = f'{name}交易细节.csv'
        df.to_csv(trading_detail_filename, index=False)

        # 假设开始时有1元资金,实操时每个月还得归集一下资金，以免收益不平均
        cash_balance = 1
        # 用于记录每日的资金余额
        daily_cash_balance = {}

        df_strategy = pd.DataFrame(columns=['日期', '执行策略'])
        df_daily_return = pd.DataFrame(columns=['日期', '收益率'])

        cash_balance_list = []
        # 记录每个交易日是否执行了策略，并输出到csv文件中
        for date, group in df.groupby('日期'):
            # 如果当日没有入选标的，则单日收益率为0
            if group.empty:
                daily_return = 0
            else:
                daily_return = ((group[f'{n}日后总涨跌幅（未来函数）'] +
                                1).mean()*(1-m)-1)/n  # 计算平均收益率
            df_daily_return = pd.concat(
                [df_daily_return, pd.DataFrame({'日期': [date], '收益率': [daily_return]})])
            # 更新资金余额并记录每日资金余额
            cash_balance *= (1 + daily_return)
            daily_cash_balance[date] = cash_balance
            cash_balance_list.append(cash_balance)  # 添加每日资金余额到列表中
        df_cash_balance = pd.DataFrame(
            {'日期': list(daily_cash_balance.keys()), '资金余额': list(daily_cash_balance.values())})
        df_strategy_and_return = pd.merge(
            df_daily_return, df_cash_balance, on='日期')
        # 输出每日执行策略和净资产收益率到csv文件
        # df_strategy_and_return.to_csv(f'/{name}每日策略和资产状况.csv', index=False)
        df_strategy_and_return.to_csv(f'./资产变动/{name}资产变动.csv', index=False)
    except Exception as e:
        print(f"发生bug: {e}")
